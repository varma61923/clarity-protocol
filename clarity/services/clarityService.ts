// This file simulates the backend monolith provided by the user.
// It includes configuration, services, and logic that would typically run on a server.

// SECTION 1: PLATFORM CONFIGURATION
export const ClarityConfig = {
    aiContentRejection: {
        enabled: true,
        patterns: [
            /as an ai language model/i,
            /i cannot express personal opinions/i,
            /in conclusion, while .* can be debated/i,
            /as a large language model/i,
            /i am not able to/i,
            /i do not have beliefs/i,
            /based on my knowledge cutoff/i,
            /generated by .* gpt/i
        ],
    },
    governance: {
        donationFeeBps: 100, // 1% fee (100 basis points)
    }
};


// SECTION 2: SIMULATED BACKEND SERVICES

/**
 * A placeholder service to fulfill the "Rejects AI-generated content" requirement.
 */
export const aiContentCheckService = {
    /**
     * Performs a heuristic check for AI-generated text patterns.
     * @param {string} textContent The article text to analyze.
     * @returns {Promise<boolean>} `true` if it passes the check, `false` if it seems AI-generated.
     */
    isHumanAuthored: async (textContent: string): Promise<boolean> => {
        if (!ClarityConfig.aiContentRejection.enabled) {
            return true;
        }
        for (const pattern of ClarityConfig.aiContentRejection.patterns) {
            if (pattern.test(textContent)) {
                console.warn(`[AI Check] Rejected content due to pattern: ${pattern}`);
                return false;
            }
        }
        return true;
    },
};

/**
 * A placeholder service to simulate ZK-based watermarking to deter AI scraping.
 */
export const zkWatermarkingService = {
    /**
     * Applies a subtle, verifiable transformation to text.
     * In this simulation, it injects a zero-width space after common words.
     * A real implementation would use more sophisticated linguistic steganography.
     * @param {string} textContent The text to watermark.
     * @returns {string} The watermarked text.
     */
    applyWatermark: (textContent: string): string => {
        console.log("[ZK Watermark] Applying simulated watermark to content.");
        // Replaces common words with the word followed by a zero-width space (U+200B)
        return textContent
            .replace(/ the /g, ' the​ ')
            .replace(/ is /g, ' is​ ')
            .replace(/ a /g, ' a​ ')
            .replace(/ and /g, ' and​ ');
    }
};


/**
 * Simulates interactions with IPFS for content and metadata storage.
 */
export const ipfsService = {
    /**
     * "Pins" content to IPFS.
     * @param {string | object} content The JSON data or text to pin.
     * @returns {Promise<string>} A mock IPFS CID (Content Identifier).
     */
    pin: async (content: string | object): Promise<string> => {
        // In a real app, this would interact with an IPFS node/pinning service.
        // For simulation, we generate a random hash to act as a CID.
        console.log("[IPFS Service] Pinning content...");
        const contentString = typeof content === 'string' ? content : JSON.stringify(content);
        // Using simple random string generation for mock CID
        const randomString = Math.random().toString(36).substring(2) + Date.now().toString(36);
        const mockCid = `bafybei${randomString}`;
        console.log(`[IPFS Service] Successfully pinned content. Mock CID: ${mockCid}`);
        await new Promise(resolve => setTimeout(resolve, 200)); // Simulate network delay
        return mockCid;
    },
};